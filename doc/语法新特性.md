[TOC]

# TC39 提案

https://github.com/tc39/proposals

TC39提案有以下4个阶段：

**Stage 0: Strawperson：**

由TC39成员提议任何想法、修改、以前没有被提议的（或以前的提议被否决的），然后将其添加到 Stage 0 提案的页面中。

**Stage 1: Proposal：**

提案正式由TC39成员创立，提案描述一个结构化问题和解决方案。

**Stage 2: Draft：**

使用正式的规范语言精确描述提案的语法和语义。

**Stage 3: Candidate：**

提案的规范和用户的反馈已经完成。

**Stage 4：FInished：**

提案将在接下来的ECMAScript版本出现。

# ES2021

## 数字分隔符

### 语法描述

为了提高可读性，[新的 JavaScript 语言功能](https://github.com/tc39/proposal-numeric-separator) 启用了下划线作为数字中的分隔符。可以在二进制，十进制，十六进制，八进制等数字的任意位置使用下划线分割。

```js
console.log(123_123_123.01 === 123123123.01); // true
console.log(0b11111111_11111111_00001111 === 0b111111111111111100001111); // true 二进制
console.log(0o567_123_233 === 0o567123233); // true 八进制
console.log(0x76fd_123df === 0x76fd123df); // true 十六进制
```

### Babel 插件

[`[@babel/plugin-proposal-numeric-separator]`](https://babeljs.io/docs/en/babel-plugin-proposal-numeric-separator)

**已经包含在`@babel/preset-env`中**

## 逻辑分配

### 语法描述

新增逻辑分配运算符：&&=`，`||=

```js
a ||= b; // a || a=b
a &&= b; // a && a=b
```

### Babel 插件

[`@babel/plugin-proposal-logical-assignment-operators`](https://babeljs.io/docs/en/babel-plugin-proposal-logical-assignment-operators)

**已经包含在`@babel/preset-env`中**

## Weakref

### 语法描述

```
// 创建一个引用给定目标对象的 WeakRef 对象
const ref = new WeakRef(targetObject)

// 返回 WeakRef 实例的目标对象，如果目标对象已被垃圾收集，则返回 undefined
const obj = ref.deref()

// 创建一个使用给定回调的注册表对象
const registry = new FinalizationRegistry([callback])

// 使用注册实例注册一个对象，这样如果对象被垃圾收集，注册的回调可能会被调用
registry.register(target, heldValue, [unregisterToken])

// 从注册表实例中注销目标对象
registry.unregister(unregisterToken)

```

### polyfill

待定。。。

## Promise.any

### 语法描述

谁最先成功执行就返回谁，否则全部失败才返回。

`Promise.race()` ： 谁执行快就返回谁，无论成败

```js
const promises = [Promise.reject('ERROR A'), Promise.reject('ERROR B'), Promise.resolve('result')];

Promise.any(promises)
  .then((value) => {
    console.log('value: ', value); //value: result
  })
  .catch((err) => {
    console.log('err: ', err);//若全部失败，则输出  err:  AggregateError: All promises were rejected
  });
```

### polyfill

在 core-js 中 [any.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/promise/any.js)

## String.prototype.replaceAll

### 语法描述

替换字符串中全部匹配的内容

```js
'aabbcc'.replaceAll('b', '.'); //aa..cc
// 等价下面的方法
'aabbcc'.replace(/b/g, '.'); //aa..cc
```

### polyfill

在 core-js 中 [replace-all.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/string/replace-all.js)

# ES2020

## String.prototype.matchAll

### 语法描述

提供一个简单的解决方案来支持捕获组，并返回一个可迭代的数组，该数组可以扩展为数组

```js
const string = 'test1test2test3';
const regex = /(test)(\d)?/g; // g修饰符必须有

console.log(string.match(regex)); // [ 'test1', 'test2', 'test3' ]

// 获取每一次捕获的详细结果
for (const match of string.matchAll(regex)) {
  console.log(match);
  //["test1", "test", "1", index: 0, input: "test1test2test34", groups: undefined]
  //["test2", "test", "2", index: 5, input: "test1test2test34", groups: undefined]
  //["test3", "test", "3", index: 10, input: "test1test2test34", groups: undefined]
}

// 等价于
let match;
while ((match = regex.exec(string))) {
  console.log(match);
}

```

### polyfill

在 core-js 中 [match-all.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/string/match-all.js)

## 动态导入

### 语法描述

动态导入语法允许我们将`import`作为能够返回`promise`的函数进行调用。这对于在代码运行时动态加载模块特别有用。例如，您可能想基于代码中的某些逻辑来加载某个组件或模块。

```js
import(`./home.js`)  // home.js中export const export1 = ''; ....
  .then(({export1, export2})=>
    // 加载成功的回调
  })
  .catch(err => {
    // 加载失败的回调
  });
```

### Babel 插件

[`@babel/plugin-syntax-dynamic-import`](https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import)

**已经包含在`@babel/preset-env`中**

## BigInt

### 语法描述

JavaScript新增的数据类型，如果超过JavaScript 可以处理的数值范围`-2^53`～`+2^53`。就是这样`-9007199254740992`到`+9007199254740992`，就可以使用这个数据类型来标识。也可以通过`Number.MIN_SAFE_INTEGER`和`Number.MAX_SAFE_INTEGER`来判断最值。

## 使用：

需要在数字后面加一个 n 就会变成一个 BigInt 或者使用 BigInt()包起来。

```js
//与Number比较
console.log(Number(10n )=== 10) //true
console.log(10n === BigInt(10)) //true
console.log(10n === 10) //false
console.log(10n == 10) //true
//只能转换整数
console.log(BigInt(10.4)）//Uncaught RangeError: The number 10.4 cannot be converted to a BigInt...
//计算
console.log(10n + 10n)  //20n
console.log(10n - 10n)  //0n
console.log(10n * 10n)  //100n
console.log(10n / 10n)  //1n
onsole.log(14n % 10n)  //取余数。 4n
//正负数
onsole.log(-10n) //-10n
onsole.log(+10n) //Uncaught TypeError: Cannot convert a BigInt value to a number at <anonymous>:1:13
//与Number不能直接极端，需要转换成同一个类型
console.log(Number(10n)+10) //20

```

### Babel 插件

[`@babel/plugin-syntax-bigint`](https://babeljs.io/docs/en/babel-plugin-syntax-bigint)

**已经包含在`@babel/preset-env`中**

## Promise.allSettled

### 语法描述

无论它被认为是`resolve`或`reject`，都会进入正常回调流程

```js
const promises = [
  new Promise((resolve) => {
    resolve();
  }),
  new Promise((resolve, reject) => {
    reject();
  }),
  new Promise((resolve) => {
    resolve();
  })
];

Promise.allSettled(promises).then((results) =>
  results.forEach((result) => console.log(result.status))
);
```

### polyfill

在 core-js [all-settled.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/promise/all-settled.js)

## globalThis

### 语法描述

`globalThis` 是一个全新的标准方法用来获取全局 this， 对 window、self、global 的一个统一。

### polyfill

在 core-js [global-this.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/global-this.js)

## for-in

### 语法描述

`for (x in obj) ...` 是在很多时候都超级有用的语法，主要是遍历对象的 key 值。

ECMA 规范中并没有明确定义 for (x in y) 的顺序。尽管，在此之前浏览器实现了一致的顺序，但是，现在已经被纳入到 ES2020 的官方规范中了

```js
const obj = {
  name: "x1",
  age: "16"
}
for (let key in obj) {
  console.log(key+"=",boj[key]);
  //name= x1
	//age= 16
}
```

## 可选链操作符（Optional Chaining）

### 语法描述
  ?. 与 . 类似，都是获取当前结构体的成员变量，区别在于：
  . 如果一个结构体内不存在这个变量名，会返回undefined，在undefined中再去取某个变量名，会报错并中断程序运行;除非每次取值前判断一下状态；代码逻辑较复杂时，代码会很长，影响可读性；
  ?. 不需要判断当前的状态，通过短路计算获取最终的值，即取值过程中会隐式的检查取值后是不是undefined和null,如果是，则直接返回undefined;

```js
const obj = {
  foo: {
    bar: {
      baz: class {
      },
    },
  },
};

const baz = obj?.foo?.bar?.baz(); // class{}

const safe = obj?.qux?.baz(); //obj中不存在qux,直接返回undefined，不再继续往下取值了，因此不会报错，不会中断程序运行
const safe2 = obj?.foo.bar.qux?.(); // undefined 同上

const willThrow = obj?.foo.bar.qux(); // Error: not a constructor 普通的.如果有undefined，还会继续取值，导致报错

// Top classes can be called directly, too.
class Test {
}
new Test?.(); // test instance

new exists?.(); // undefined
```

### Babel 插件

[`@babel/plugin-proposal-optional-chaining`](https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining)

**已经包含在`@babel/preset-env`中**

## 空位合并运算符

### 语法描述

新增运算符：??=

属性值为 null 或 undefined 时，指定默认值

```js
a ??= b; // (a===null || a===undefined) && a = b
```

### Babel 插件

[`@babel/plugin-proposal-nullish-coalescing-operator`](https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator)

**已经包含在`@babel/preset-env`中**

## import.meta

### 语法描述

`import.meta`是一个给 JavaScript 模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的 URL。

### Babel 插件

[`@babel/plugin-syntax-import-meta`](https://babeljs.io/docs/en/babel-plugin-syntax-import-meta)

**已经包含在`@babel/preset-env`中**

## export-namespace-from

### 语法描述

```js
export * as ns from 'mod';
```

### Babel 插件

`@babel/plugin-proposal-export-namespace-from`

**已经包含在`@babel/preset-env`中**

# ES2019

## flat

### 语法描述

接收一个参数为展开的深度，它返回一个扁平数组；若不写参数，默认展开一层；若参数大于数组深度，则全部展开为一维数组；参数为0或负数，则返回原数组。

```js
const a = [1, [2, 3], [4, 5], 6, [7, [8, 9], [10, [11, 12], 13], 14], 15];
console.log(a.flat(0)); //[1, Array(2), Array(2), 6, Array(4), 15]
console.log(a.flat(1)); // [1, 2, 3, 4, 5, 6, 7, Array(2), Array(3), 14, 15]
console.log(a.flat(3)); //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
console.log(a.flat(5)); //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
```

### polyfill

在 core-js [flat.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/array/flat.js)

## flatMap

### 语法描述

**map()** + **flat()** => **flatmap()**

带有操纵值的扁平数组，由提供给它的回调函数提供。就像一个 map 一样。

先 map，再 flat, 只能展开一层数据

```js
const arr = ['Codedam', 'is Awsome', '!'];

const mapResult = arr.map((item) => item.split(' '));
console.log(mapResult); // [ [ 'Codedam' ], [ 'is', 'Awsome' ], [ '!' ] ]

const flatMapResult = arr.flatMap((chunk) => chunk.split(' '));
console.log(flatMapResult); // ['Codedam', 'is',  'Awsome', '!'];
```

### polyfill

在 core-js [flat-map.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/array/flat-map.js)

## Object.fromEntries()

### 语法描述

它是 Object.entries 的反向方法，它也是克隆对象的方法之一，切入式对象和数据通过引用复制

```js
//普通对象
const obj = {
  name: 'lxw',
  age: 20,
  sons: [1, 2, 3],
  func: () => {},
  o: {}
};
const entries = Object.entries(obj);
console.log(entries);
// 0: (2) ["name", "lxw"]
// 1: (2) ["age", 20]
// 2: (2) ["sons", Array(3)]
// 3: (2) ["func", ƒ]
// 4: (2) ["o", {…}]
// length: 5
const fromEntries = Object.fromEntries(entries);
console.log(fromEntries); // Object { age: 20,func: ()=>{},name: "lxw",o: {},sons: (3) [1, 2, 3]}
//符合转换要求的数据结构
const obj1 = [["a","1"],["b","2"],["c","3"]]
const fromEntriesX = Object.fromEntries(obj1);
console.log(fromEntriesX); //{a: "1", b: "2", c: "3"}

//如果list大于两个值，取前两个;小于两个值，则为undefined;为空，则key,value都是undefined
const obj12 = [["a","1"，"2"],["b","2"],["c"],[]]
const fromEntriesX = Object.fromEntries(obj1);
console.log(fromEntriesX); //{a: "1", b: "2", c: undefined, undefined: undefined}

console.log(obj === fromEntries); // false
console.log(obj.sons === fromEntries.sons); // true
console.log(obj.func === fromEntries.func); // true
```

### polyfill

在 core-js [from-entries.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/object/from-entries.js)

## trimStart

### 语法描述

```js
const description = '   Unlocks Secret Codes ';
console.log(description.trimStart()); // "Unlocks Secret Codes "
```

### polyfill

在 core-js [trim-start.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/string/trim-start.js)

## trimEnd

### 语法描述

```js
const category = '  JavaScript ';
console.log(category.trimEnd()); // "  JavaScript"
```

### polyfill

在 core-js [trim-end.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/string/trim-end.js)

## catch 绑定

### 语法描述

能够在不使用 catch 绑定的地方选择性地删除它

```js
try {
  // trying to use a new ES2019 feature
  // which may not be implemented in other browsers
} catch (unused) {
  // revert back to old way
}

===>

try {
  ...
} catch {
  ...
}
```

### Babel 插件

[`@babel/plugin-proposal-optional-catch-binding`](https://babeljs.io/docs/en/babel-plugin-proposal-optional-catch-binding)

**已经包含在`@babel/preset-env`中**

## Symbol描述

### 语法描述

当我们在 JS 中创建一个 Symbol 时，可以指定一个在以后用于调试的描述。必须在 `toString()` 方法的帮助下才能访问描述。

ES10 添加了一个新的名为 description 的只读属性，它返回 Symbol 的描述。

```
const mySymbol = Symbol("myDescription");

console.log(mySymbol.toString()); // Symbol(myDescription)

console.log(mySymbol.description); // myDescription
```

### polyfill

在 core-js [description.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/symbol/description.js)

## Function.prototype.toString - 修订版

我们之前已经在函数原型中使用了`toString`方法，但是在 ES2019 中它已被修改并包含函数内的注释，请注意它在`Arrow Functions`上不起作用。

```js
function /* comment */ foo /* another comment */() {}

// Before
console.log(foo.toString()); // function foo(){}

// Now ES2019
console.log(foo.toString()); // function /* comment */ foo /* another comment */ (){}

// Arrow Syntax
const bar /* comment */ = /* another comment */ () => {};

console.log(bar.toString()); // () => {}
```

## JSON 变动

JavaScript 规定有 5 个字符，不能在字符串里面直接使用，只能使用转义形式。

```js
U+005C：反斜杠（reverse solidus)
U+000D：回车（carriage return）
U+2028：行分隔符（line separator）
U+2029：段分隔符（paragraph separator）
U+000A：换行符（line feed）
```

举例来说，字符串里面不能直接包含反斜杠，一定要转义写成\或者\u005c。

这个规定本身没有问题，麻烦在于 JSON 格式允许字符串里面直接使用 U+2028（行分隔符）和 U+2029（段分隔符）。这样一来，服务器输出的 JSON 被 JSON.parse 解析，就有可能直接报错。

```
let jso = '"\u2028"';
JSON.parse(jso); // 可能报错
```

JSON 格式已经冻结（RFC 7159），没法修改了。为了消除这个报错，ES2019 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。

根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的 JSON.stringify()方法有可能返回不符合 UTF-8 标准的字符串。

具体来说，UTF-8 标准规定，0xD800 到 0xDFFF 之间的码点，不能单独使用，必须配对使用。比如，\uD834\uDF06 是两个码点，但是必须放在一起配对使用，代表字符?。这是为了表示码点大于 0xFFFF 的字符的一种变通方法。单独使用\uD834 和\uDFO6 这两个码点是不合法的，或者颠倒顺序也不行，因为\uDF06\uD834 并没有对应的字符。

JSON.stringify()的问题在于，它可能返回 0xD800 到 0xDFFF 之间的单个码点。

```js
JSON.stringify('\u{D834}'); // "\u{D834}"
```

**为了确保返回的是合法的 UTF-8 字符，ES2019 改变了 JSON.stringify()的行为。如果遇到 0xD800 到 0xDFFF 之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。**

```js
JSON.stringify('\u{D834}'); // ""\\uD834""
JSON.stringify('\uDF06\uD834'); // ""\\udf06\\ud834""
```

参考： https://blog.csdn.net/weixin_44182099/article/details/97868718

### Babel 插件

[`@babel/plugin-proposal-json-strings`](https://babeljs.io/docs/en/babel-plugin-proposal-json-strings)

**已经包含在`@babel/preset-env`中**

# ES2018

## 异步迭代

### 语法描述

**for await (let val of stream)**

```js
// 生成迭代器
async function* genAnswers() {
  var stream = [Promise.resolve(4), Promise.resolve(9), Promise.resolve(12)];
  var total = 0;
  for await (let val of stream) {
    total += await val;
    yield total;
  }
}

function forEach(ai, fn) {
  return ai.next().then(function (r) {
    if (!r.done) {
      fn(r);
      return forEach(ai, fn);
    }
  });
}

var output = 0;
forEach(genAnswers(), function (val) {
  output += val.value;
}).then(function () {
  console.log(output); // 42
});

// 不使用迭代器
async function genAnswers() {
  var stream = [Promise.resolve(4), Promise.resolve(9), Promise.resolve(12)];
  var total = 0;
  for await (let val of stream) {
    console.log(val);//第一次：4  第二次：9  第三次：12
    total += val; //第一次：4 第二次：13 第三次：25
  }
  return total; //25
}

genAnswers().then((res) => {
  console.log(res); //25
});
```

### Babel 插件

[`@babel/plugin-proposal-async-generator-functions`](https://babeljs.io/docs/en/babel-plugin-proposal-async-generator-functions)

**已经包含在`@babel/preset-env`中**

## Promise.finally

不管成功或失败，都会执行finally。

### 语法描述

```js
function doSomething() {
  doSomething1()
    .then(doSomething2)
    .then(doSomething3)
    .catch((err) => {
      console.log(err);
    })
    .finally(() => {
      // finish here!
    });
}
```

### polyfill

在 core-js [finally.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/promise/finally.js)

## Rest/Spread 属性

### 语法描述

为对象解构提供了和数组一样的 Rest 参数（）和展开操作符

```js
// 对象解构
const myObject = {
  a: 1,
  b: 2,
  c: 3
};

const { a, ...x } = myObject;
// a = 1
// x = { b: 2, c: 3 }

// Rest参数
function restParam({ a, ...x }) {
  // a = 1
  // x = { b: 2, c: 3 }
}

restParam({
  a: 1,
  b: 2,
  c: 3
});

// 扩展运算符可以在其他对象内使用, 可以进行对象的浅复制
const obj1 = { a: 1, b: 2, c: 3 };
const obj2 = { ...obj1, z: 26 };
// obj2 is { a: 1, b: 2, c: 3, z: 26 }
```

### Babel 插件

[`babel-plugin-proposal-object-rest-spread`](https://babeljs.io/docs/en/babel-plugin-proposal-object-rest-spread)

**已经包含在`@babel/preset-env`中**

## 正则表达式命名捕获组

### 语法描述

```js
var re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
console.log(re.exec('1999-02-29').groups.year);
```

### Babel 插件

[`@babel/plugin-transform-named-capturing-groups-regex`](https://babeljs.io/docs/en/babel-plugin-transform-named-capturing-groups-regex)

**已经包含在`@babel/preset-env`中**

## 正则表达式反向断言

// TODO

### Babel 插件

**已经包含在`@babel/preset-env`中**

## 正则表达式 dotAll 模式

### 语法描述

正则表达式中点`.`匹配除回车外的任何单字符，标记`s`改变这种行为，允许行终止符的出现

```js
/hello.world/.test('hello\nworld'); // false
/hello.world/s.test('hello\nworld'); // true
```

### polyfill

在 core-js [dot-all.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/regexp/dot-all.js)

### Babel 插件

[`@babel/plugin-transform-dotall-regex`](https://babeljs.io/docs/en/babel-plugin-transform-dotall-regex)

**已经包含在`@babel/preset-env`中**

## 正则表达式 Unicode 转义

### Babel 插件

[`@babel/plugin-proposal-unicode-property-regex`](https://babeljs.io/docs/en/babel-plugin-proposal-unicode-property-regex)

**已经包含在`@babel/preset-env`中**

## 非转义序列的模板字符串

### Babel 插件

**已经包含在`@babel/preset-env`中**

# ES2017

## async await

### 语法描述

```js
async function foo() {
  await bar();
}
```

### Babel 插件

[`@babel/plugin-transform-async-to-generator`](https://babeljs.io/docs/en/babel-plugin-transform-async-to-generator)

**已经包含在`@babel/preset-env`中**

## Object.values

### 语法描述

`Object.values` 方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用`for...in`循环的顺序相同（区别在于`for...in`循环枚举原型链中的属性）

```js
const a = { C: '1' };
Object.values(a); // ["1"]
```

### polyfill

在 core-js [values.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/object/values.js)

## Object.getOwnPropertyDescriptors

### 语法描述

`Object.getOwnPropertyDescriptors()`返回一个对象的所有自身属性的描述（`.value`,`.writable`,`.get`,`.set`,`.configurable`,`enumerable`）

```js
const a = { C: '1' };
Object.getOwnPropertyDescriptors(a);//C: {value: "1", writable: true, enumerable: true, configurable: true}
```

### polyfill

在 core-js [get-own-property-descriptors.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/object/get-own-property-descriptors.js)

## 填充字符串

### 语法介绍

`padStart()`和`padEnd()`，填充字符串达到当前长度

```js
'aa'.padStart(4, 1); // 11aa
'aa'.padEnd(4, 1); // aa11
'aa'.padStart(4, 1234); // 12aa
'abcdef'.padStart(4, 1234); // abcdef
```

### polyfill

在 core-js [pad-end.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/string/pad-end.js) [pad-start.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/string/pad-start.js)

## 共享内存数据

`ShareArrayBuffer`和`Atomics`用于从共享内存位置读取和写入

# ES2016

## includes

### 语法介绍

数组`includes()`方法，用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回`true`，否则返回`false`。

### polyfill

在 core-js [includes.js](https://github.com/zloirock/core-js/blob/master/packages/core-js/stable/string/includes.js)

## 指数运算符

### 语法介绍

`a ** b`指数运算符，它与 `Math.pow(a, b)`相同

### Babel 插件

[`@babel/plugin-transform-exponentiation-operator`](https://babeljs.io/docs/en/babel-plugin-transform-exponentiation-operator)

**已经包含在`@babel/preset-env`中**

## 装饰器

`decorator`（装饰器）是 ES7 中的一个提案，目前处于 `stage-2` 阶段，提案地址：[JavaScript Decorators](https://github.com/tc39/proposal-decorators)。

装饰器与之前讲过的函数组合（`compose`）以及高阶函数很相似。装饰器使用 `@` 作为标识符，被放置在被装饰代码前面。在其他语言中，早就已经有了比较成熟的装饰器方案。

装饰器虽然还属于不稳定的语法，但在很多框架中都已经广泛使用，例如 Angular、Nestjs 等等，和 Java 中的注解用法非常相似。

### 工具库

https://www.npmjs.com/package/core-decorators

### Babel 插件

[`@babel/plugin-proposal-decorators`](https://babeljs.io/docs/en/babel-plugin-proposal-decorators)

### 参考

https://juejin.cn/post/6844904100144889864

# ES2015

ES6已经非常成熟了，下面只关注语法本身，不再列举对应的babel和polyfill

## 声明

变量声明：const、let

声明关键字： var、const、let、function、class、import

## 解构赋值

 **字符串解构**：`const [a, b, c, d, e] = "hello"` 

​	`console.log(a,b,c,d,e)  // h e l l o`

 **数值解构**：`const { toString: s } = 123`

​	`console.log(s)  // f toString()`

 **布尔解构**：`const { toString: b } = true`

​	`console.log(b)  //ƒ toString()`

**对象解构**

- 形式：`const { x, y } = { x: 1, y: 2 }`
- 默认：`const { x, y = 2 } = { x: 1 }`
- 改名：`const { x, y: z } = { x: 1, y: 2 }`

**数组解构**

- 规则：数据结构具有`Iterator接口`可采用数组形式的解构赋值
- 形式：`const [x, y] = [1, 2]`
- 默认：`const [x, y = 2] = [1]`

**函数参数解构**

- 数组解构：`function Func([x = 0, y = 1]) {}`
- 对象解构：`function Func({ x = 0, y = 1 } = {}) {}`

## 对象扩展

**Object.is()**：对比两值是否相等

 **Object.assign()**：合并对象(浅拷贝)，返回原对象

 **Object.getPrototypeOf()**：返回对象的原型对象

 **Object.setPrototypeOf()**：设置对象的原型对象

 **__proto__**：返回或设置对象的原型对象

### 遍历

`for-in`：遍历对象`自身可继承可枚举`属性

`Object.keys()`：返回对象`自身可枚举`属性键组成的数组

`Object.getOwnPropertyNames()`：返回对象`自身非Symbol`属性键组成的数组

`Object.getOwnPropertySymbols()`：返回对象`自身Symbol`属性键组成的数组

`Reflect.ownKeys()`：返回对象`自身全部`属性键组成的数组

- 首先遍历所有数值键，按照数值升序排列
- 其次遍历所有字符串键，按照加入时间升序排列
- 最后遍历所有Symbol键，按照加入时间升序排列

## 模板

## 字符串扩展

 **String.raw()**：返回把字符串所有变量替换且对斜杠进行转义的结果

 **String.fromCodePoint()**：返回码点对应字符

 **codePointAt()**：返回字符对应码点(`String.fromCodePoint()`的逆操作)

 **normalize()**：把字符的不同表示方法统一为同样形式，返回`新字符串`(Unicode正规化)

 **repeat()**：把字符串重复n次，返回`新字符串`

 **matchAll()**：返回正则表达式在字符串的所有匹配

 **includes()**：是否存在指定字符串

 **startsWith()**：是否存在字符串头部指定字符串

 **endsWith()**：是否存在字符串尾部指定字符串

## 数值扩展

**二进制表示法**：`0b或0B开头`表示二进制(`0bXX`或`0BXX`)

 **八进制表示法**：`0o或0O开头`表示八进制(`0oXX`或`0OXX`)

 **Number.EPSILON**：数值最小精度

 **Number.MIN_SAFE_INTEGER**：最小安全数值(`-2^53`)

 **Number.MAX_SAFE_INTEGER**：最大安全数值(`2^53`)

 **Number.parseInt()**：返回转换值的整数部分

 **Number.parseFloat()**：返回转换值的浮点数部分

 **Number.isFinite()**：是否为有限数值

 **Number.isNaN()**：是否为NaN

 **Number.isInteger()**：是否为整数

 **Number.isSafeInteger()**：是否在数值安全范围内

 **Math.trunc()**：返回数值整数部分

 **Math.sign()**：返回数值类型(`正数1`、`负数-1`、`零0`)

 **Math.cbrt()**：返回数值立方根

 **Math.clz32()**：返回数值的32位无符号整数形式

 **Math.imul()**：返回两个数值相乘

 **Math.fround()**：返回数值的32位单精度浮点数形式

 **Math.hypot()**：返回所有数值平方和的平方根

 **Math.expm1()**：返回`e^n - 1`

 **Math.log1p()**：返回`1 + n`的自然对数(`Math.log(1 + n)`)

 **Math.log10()**：返回以10为底的n的对数

 **Math.log2()**：返回以2为底的n的对数

 **Math.sinh()**：返回n的双曲正弦

 **Math.cosh()**：返回n的双曲余弦

 **Math.tanh()**：返回n的双曲正切

 **Math.asinh()**：返回n的反双曲正弦

 **Math.acosh()**：返回n的反双曲余弦

 **Math.atanh()**：返回n的反双曲正切

## 数组扩展

### 扩展运算符

`...`可以将一个类数组，数组，字符串、实现了Iterator接口的对象。

```js
console.log(...[1,2,3]) // 1 2 3

console.log(1, ...[2,3,4], 5) // 1 2 3 4 5

[...document.querySelectorAll('div')] // [<div>, <div>, <div>]

function add(x, y){
    return x + y
}
const n = [3, 5]
add(...n) // 8

//Generator函数
 const go = function*(){
     yield 1;
     yield 2;
     yield 3;
 }
 [...go()] // [1, 2, 3]
```

### Array.from

将可以被展开的变量转化成数组

```js
let arrLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
}
// ES5 
var a1 = [].slice.call(arrLike)
// ES6
var a2 = Array.from(arrLike, ()=>{})
```

### Array.of

用于将一组值，转换为数组。主要用来弥补Array函数因为参数个数不同而导致的差异

```js
Array.of(3,11,6) // [3, 11, 6]
Array.of(3) // [3]
Array.of(4).length // 1
```

### 数组的实例 copyWithin

将当前数组中指定位置的元素复制到另外一个位置，并且会覆盖那个位置的原有元素，会修改当前数组

1. target(必须)：从该位置开始替换数据，如果是负值，则倒数 
2. start(可选)：从该位置读取数据，默认0，负值同上 
3. end(可选)：到这个位置停止读取数据，默认等于数组长度，负值同上

```js
let p = [1,2,3,4,5,6,7]
p.copyWithin(0,5,7) //左（start）闭右（end）开
[6, 7, 3, 4, 5, 6, 7]
```

### 数组实例的 find 和 findIndex

find 用来找出数组中符合条件的成员，它的参数是一个回调函数，找到一个返回值为true的返回，如果没有则返回undefined

find 方法的回调函数有三个参数:

1. value // 当前值
2. index // 当前的位置
3. arr // 原数组

```js
let s = [1,2,3,4,5,6]

s.find(x => x > 4)
// 5
```

findIndex 同find方法类似，只不过都不符合返回的是 -1,而且符合是返回符合条件值的位置而不是值。

```js
let s = [1,2,3,4,5,6]
s.find(x => x > 4)
// 4
```

### 数组实例的 fill

通过给定值，填充一个数组

```js
let sz = [1,2,3,4,5,6]
sz.fill(1) // [1,1,1,1,1,1]
sz.fill(1,0,3) //[1,1,1,4,5,6]
// 接受三个参数，第一个为填充值，第二个为起始位置，第三个为截至位置(不包含这个位置)

sz.fill(1,3) // [1,2,3,1,1,1]
// 如果省略最后一个参数，则默认从起始位置到数组默认长度结束
```

### 数组实例的 entries, keys, values

三种方法主要用于遍历数组，可以用 for...of...进行遍历，keys()对应键名，values对应键值,entries()对键值对的遍历

```js
let bo = ['a', 'c']

for(let r of bo.keys()){
	console.log(r) // 0 1
}
// 0 1

for(let n of bo.values()){
	console.log(n) 
}
// a c

for(let s of bo.entries()){
	console.log(s)
}
// [0, "a"]
// [1, "c"]
```

### 数组实例的 includes

用来表示某个数组是否包含给定的值，返回一个布尔值

```js
let i = ['a',1,2,3]

i.includes()  // false
i.includes(1) // true
i.includes(10) // false

```

indexOf 和includes 的区别，indexOf // 不够语义化，它的作用是找到参数出现的第一个位置， 所以要比较是否为 -1,另外由于 内部使用的是 ===  则导致NaN 的误判，includes // 使用的是不一样的算法，则不会有这个问题

```
[NaN].indexOf(NaN) // -1
[NaN].includes(NaN) // true
```

### 数组的空位(避免出现空位)

数组的空位指的是该数组中某一个位置没有任何值。另外空位不是undefined，如果一个位置的值是undefined，那么这个位置还是有值的。

```js
Array(3) // [, , ,]
```

ES5中大多数情况中对待空位都是会忽略

```js
- forEach(), filter(), reduce(), every() 和 some() 都会跳过空位
- map() 跳过但保留这个值
- join() 和 toString() 中 空位 === undefined，而 undefined和null会被处理成空字符串
```

ES6 中 空位则转换为undefined

```js
- Array.from([1,,2]) // [1, undefined, 2]
- [...['a',,'b']]    // [ "a", undefined, "b" ]
entries()
keys()
values()
find()
findIndex()  // 都会将空位处理成undefined。
```

## 函数扩展

参考：https://juejin.cn/post/6930428551091109896#heading-1

### 默认参数

#### Es5处理默认参数

```js
function person(name, age) {
    name = typeof(name) != "undefined" ? name : `蛙人${+ new Date()}`
    age = typeof(age) != "undefined" ? age : 24
    
}
person()
```

#### Es6处理默认参数

```js
// 只有参数为undefined的时候才会触发默认参数
function person(name = "蛙人", age = 24) {
    console.log(name, age)
}
person()  // 蛙人 24
person("张三", 30) // 张三 30
person(null, null) // null null

// 函数
function defaultName() {
    return "蛙人"
}
function person(name = defaultName()) {
    console.log(name)
}

// 变量
let defaultName = "蛙人"
function person(name = defaultName) {
    console.log(name)
}

// 前面的值
function person(name, nickName = name) {
     console.log(name, nickName)
}

// 不合法会报错
function person(name = nickName, nickName) {
     console.log(name, nickName)
}
person(undefined, '张三');
```

### 函数参数默认值对arguments的影响

#### Es5非严格模式下使用arguments

Es5非严格模式下，函数命名参数的变化会体现在`arguments`对象上，`arguments`获取的是当前函数的实参，`arguments`在非严格模式下它跟形参是映射关系，就是形参有变化`arguments`跟着变。

```js
function test(a, b) {
    console.log(a == arguments[0]) // true
    console.log(b == arguments[1]) // true
    a = "a"
    b = "b"
    console.log(arguments) // ["a", "b"]
}
test(1, 2)
```

#### Es5严格模式下使用arguments

```js
function test(a, b) {
    'use strict';

    console.log(arguments)  // [1, 2]
    b = 10
    console.log(arguments) // [1, 2]
}
test(1, 2)
```

#### Es6中使用默认参数值对arguments的影响

在Es6中，如果一个函数使用了默认参数值，那么`arguments`对象的行为都将与`JavaScript`中的严格模式下保持一致。

```js
 function test(a, b = 2) {
    a = 12
    b = 10
    console.log(arguments) // [1]
}
test(1)
```

### rest参数

```js
// 方式1
function test(...parmas) {
    console.log(params) // [1, 2, 3, 4]
}
test(1, 2, 3, 4)

// 方式2
function test(a, b, ...params) {
    console.log(params)
}
test(1, 2, 3, 4)

// 错误写法，不定参数只能写到最后面
function test(...params, a, b) {
	
}
test()

// 错误写法 setter只接收一个参数
let obj = {
  set name(...params) {

  }
}
```

### 函数name属性

在`JavaScript`中所有的函数都有一个`name`属性，该属性保存的是该函数名称的字符串。没有名称的函数也仍然有`name`属性，该`name`属性值为空字符串。

```js
function person() {}
let test = function() {}

console.log(person.name) // person
console.log(test.name) // test

```

#### name属性的特殊情况

```js
var person = {
    get getName() {
        return "蛙人"
    }
}
console.log(Object.getOwnPropertyDescriptor(person, 'getName').get.name)  // get getName

function test() {}
console.log(test.bind().name) // bound test

```

`person.getName`是一个取值函数`getter`，所以它的函数名称`get getName`，如果是`setter`函数的话那么名称会有带有前缀`set`。通过`bind`创建的函数，它的名称带有"bound"前缀。

### 箭头函数

#### 箭头函数语法

```js
let person = val => "lxw"
let person = (val) => "lxw"
let person = (val) => {
	return "lxw"
}
let person = (val) => ({
	name: "lxw"
})
```

#### 箭头函数没有this

箭头函数的`this`值，取决于函数外部非箭头函数的`this`值，如果上一层还是箭头函数，那就继续往上找，如果找不到那么`this`就是`window`对象

```js
let person = {
    test: () => {
        console.log(this)
    },
    fn() {
        return () => {
            console.log(this)
        }
    }
}
person.test()  // window
person.fn()()  // person对象

```

#### 箭头函数没有`arguments`对象

同样箭头函数也没有`arguments`对象，但是如果它外层还有一层非箭头函数的话，就会去找外层的函数的`arguments`对象

```js
let test1 = () => console.log(arguments)  // 执行该函数会抛出错误


function test2(a, b, c) {
    return () => {
        console.log(arguments) // [1, 2, 3]
    }
}
test2(1, 2, 3)()

```

注意：箭头函数找arguments对象只会找外层非箭头函数的函数，如果外层是一个非箭头函数的函数如果它也没有arguments对象也会中断返回，就不会在往外层去找了

```js
function test(a) {
    return function() {
        return () => {
            console.log(arguments) // []
        }
    }
}
test(1)()()
```

#### 箭头函数不能用`new`关键字声明

```js
let test = () => {}
new test() // 抛出错误，找不到constructor对象
```

#### 箭头函数没有原型`prototype`

```js
let test = () => {}
test.prototype // undefined
```

#### 箭头函数不能改变`this`指向

```js
let person = {}
let test = () => console.log(this)

test.bind(person)()
test.call(person)
test.apply(person)
```

#### 箭头函数不能重复命名参数

## Unicode

UTF-8 标准规定，0xD800 到 0xDFFF 之间的码点，不能单独使用，必须配对使用。这是为了表示码点大于 0xFFFF 的字符的一种变通方法

ES6 增强了 Unicode 的功能,包括

- 支持字符的 Unicode 表示法

举例来说，“中”的 Unicode 码点是 `U+4e2d`，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式`\u4e2d`，两者是等价的。

```js
"中" === "\u4e2d"; // true
"中" ==="\u{4e2d}"; // true
```

- 使用`/u`匹配码点的正则表达式

```js
"𠮷".match(/./u)[0].length == 2;
```

- 获取 32 位的 UTF-16 字符的码点-**codePointAt**

```js
"𠮷".codePointAt(0) == 0x20bb7;

let s = "𠮷a";
for (let ch of s) { // 只有for of 才能正确循环获取码点
  console.log(ch.codePointAt(0).toString(16));
}
```

## 正则的扩展

参考： https://juejin.cn/post/6856402002763743240

### RegExp构造函数

```js
//下列是等价的
var regex = new RegExp('xyz','i');//第二个参数表示正则表达式的修饰符(flag)
var regex = /xyz/i;

var regex = new RegExp(/xyz/i);
var regex = /xyz/i;

//错误示例
var regex = new RegExp(/xyz/,'i');
//ES5中不允许使用第二个参数添加修饰符

//ES6
var regex = new RegExp(/abc/ig,'i').flags;
//此处的ig修饰符将会被i取代

```

### 字符串的正则方法

match()，replace()，search()，split()四种方法。

ES6将这四个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。

- String.prototype.match 调用RegExp.prototype[Symbol.match]
- String.prototype.replace 调用RegExp.prototype[Symbol.replace]
- String.prototype.search 调用RegExp.prototype[Symbol.search]
- String.prototype.split 调用RegExp.prototype[Symbol.split]

```js
const str = 'dsd lvxw dsds dsds sdd lvsew lvxw';
const regex = new RegExp(/lvxw/g);
console.log(str.match(regex));
```

### u修饰符

“Unicode”模式，处理大于/uFFFF的Unicode字符

```js
// 普通正则无法正确匹配 大于 0xFFFF 码点的字符
"😊".match(/./) // ["\ud83d", index: 0, input: "😊", groups: undefined]
// 增加 u 修饰符，可以正常匹配
"😊".match(/./u) // ["😊", index: 0, input: "😊", groups: undefined]
```

### 正确计算字符数

```
"as😊吕小伟".match(/./gu).length
```

### i修饰符

```js
/[a-z]/i.test('\u212A') // false
/[a-z]/iu.test('\u212A') // true
```

由于`\u004B`与`\u212A`都是大写的`K`，相类似，不添加u修饰符，就无法识别非规范的K字符，因而识别的时候会出现错误

### RegExp.prototype.unicode属性

unicode属性表示是否设置了u修饰符

```js
const r1 = /hello/;
const r2 = /hello/u;

r1.unicode // false
r2.unicode // true
```

### y修饰符

“粘连”(sticky)修饰符，y修饰符的作用与g修饰符相类似，也是全局匹配

```js
var s = 'aaa_aa_a';
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]

r1.exec(s) // ["aa"]
r2.exec(s) // null
```

g修饰符只要剩余位置存在匹配即可返回值；y修饰符则是确保匹配必须从剩余的第一个位置开始，也就是上面第二次调用r2正则表达式中，剩余的第一个位置是“_”，因此不符合匹配，返回null。

### lastIndex

```js
// lastIndex 可以指定匹配的开始位置， index匹配成功的位置
const REGEX = /a/g;

// 指定从2号位置（y）开始匹配
REGEX.lastIndex = 2;

// 匹配成功
const match = REGEX.exec('xaya');

// 在3号位置匹配成功
match.index // 3

// 下一次匹配从4号位开始
REGEX.lastIndex // 4

// 4号位开始匹配失败
REGEX.exec('xaya') // null
```

### RegExp.prototype.sticky

ES6的正则实例多了sticky属性，表示是否设置了y修饰符

```js
var r = /hello\d/y;
r.sticky // true
```

### RegExp.prototype.flags

ES6为正则表达式设置了flags属性，返回正则表达式的修饰符

```js
// ES5 的 source 属性
// 返回正则表达式的正文
/abc/ig.source
// "abc"

// ES6 的 flags 属性
// 返回正则表达式的修饰符
/abc/ig.flags
// 'gi'
```

### s 修饰符：dotAll 模式

`.`代表任意的单个字符，四个字节的UTF-16字符可以用u修饰符解决；而行终止符则不能解决

- U+000A 换行符（`\n`）
- U+000D 回车符（`\r`）
- U+2028 行分隔符（line separator）
- U+2029 段分隔符（paragraph separator）

s修饰符可以让`.`匹配到任意单个字符

```js
/foo.bar/.test('foo\nbar')// false
/foo[^]bar/.test('foo\nbar')// true
/foo.bar/s.test('foo\nbar') // true
```

dotAll属性，返回一个布尔值，表示正则表达式是否处于dotAll模式

```js
const re = /foo.bar/s;
// 另一种写法
// const re = new RegExp('foo.bar', 's');

re.test('foo\nbar') // true
re.dotAll // true
re.flags // 's'
```

`/s`修饰符和多行修饰符`/m`不冲突，两者一起使用的情况下，`.`匹配所有字符，而`^`和`$`匹配每一行的行首和行尾。

### 断言

#### 先行断言和先行否定断言

“先行断言”指的是，`x`只有在`y`前面才匹配，必须写成`/x(?=y)/`

“先行否定断言”指的是，`x`只有不在`y`前面才匹配，必须写成`/x(?!y)/`

```js
/\d+(?=%)/.exec('100% of US presidents have been male')  // ["100"]
/\d+(?!%)/.exec('that’s all 44 of them')                 // ["44"]
复制代码
```

注意：“先行断言”括号之中的部分（`(?=%)`）不计入计算结果

#### 后行断言和后行否定断言

“后行断言”指的是，`x`只有在`y`后面才匹配，必须写成`/(?<=y)x/`

“后行否定断言”指的是，`x`只有不在`y`后面才匹配，必须写成`/(?<!y)x/`

```javascript
/(?<=\$)\d+/.exec('Benjamin Franklin is on the $100 bill')  // ["100"]
/(?<!\$)\d+/.exec('it’s is worth about €90')                // ["90"]
```

注意：括号之中的部分（`(?<=\$)`）不计入计算结果

#### 操作顺序

先匹配`/(?<=y)x/`的`x`，再往左匹配`y`的部分；以“先右后左”的执行顺序（与其他正则操作相反）

```javascript
/(?<=(\d+))(\d+)$/.exec('1053') // ["053", "1", "053"]
/^(\d+)(\d+)$/.exec('1053') // ["1053", "105", "3"]
```

上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是`105`和`3`。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是`1`和`053`。

```js
/(?<=(o)d\1)r/.exec('hodor')  // null
/(?<=\1d(o))r/.exec('hodor')  // ["r", "o"]
/(?<=\2(d)(o))r/.exec('hodor') // ["r", "d", "o"]
// 后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。
// 第一个null是因为不存在odr这种情况
```

### Unicode 属性类

`\p{...}`和`\P{...}`，允许正则表达式匹配符合 Unicode 某种属性的所有字符

```javascript
const regexGreekSymbol = /\p{Script=Greek}/u;
regexGreekSymbol.test('π') // true
```

`\p{Script=Greek}`指定匹配一个希腊文字母，所以匹配`π`成功

Unicode 属性类要指定属性名和属性值

```javascript
\p{UnicodePropertyName=UnicodePropertyValue}
//某些属性，可以只写属性名，或者只写属性值
\p{UnicodePropertyName}
\p{UnicodePropertyValue}
```

`\P{…}`是`\p{…}`的反向匹配，即匹配不满足条件的字符

注意：这两种类只对Unicode有效，使用的时候必须加上`u`修饰符，若不添加，在正则表达式使用`\p`和`\P`会报错

```javascript
const regex = /^\p{Decimal_Number}+$/u;
regex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true
//属性类指定匹配所有十进制字符
```

`\p{Number}`能匹配罗马数字

```javascript
// 匹配所有数字
const regex = /^\p{Number}+$/u;
regex.test('²³¹¼½¾') // true
regex.test('㉛㉜㉝') // true
regex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true

// 匹配所有空格
\p{White_Space}

// 匹配各种文字的所有字母，等同于 Unicode 版的 \w
[\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]

// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W
[^\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]

// 匹配 Emoji
/\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}|\p{Emoji}\uFE0F/gu

// 匹配所有的箭头字符
const regexArrows = /^\p{Block=Arrows}+$/u;
regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true
```

### 具名组匹配

给组匹配指定名称

```js
const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj.groups.year; // 1999
const month = matchObj.groups.month; // 12
const day = matchObj.groups.day; // 31
```

字符串替换，使用`$<组名>`引用具名组

```js
let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;
'2015-01-02'.replace(re, '$<day>/$<month>/$<year>') // '02/01/2015'
```

注意：`replace`方法的第二个参数是一个字符串，而不是正则表达式

`replace`方法的第二个参数还可以是函数

```js
'2015-01-02'.replace(re, (
   matched, // 整个匹配结果 2015-01-02
   capture1, // 第一个组匹配 2015
   capture2, // 第二个组匹配 01
   capture3, // 第三个组匹配 02
   position, // 匹配开始的位置 0
   S, // 原字符串 2015-01-02
   groups // 具名组构成的一个对象 {year, month, day}
 ) => {
 let {day, month, year} = groups;
 return `${day}/${month}/${year}`;
});

```

在正则表达式内部引用某个“具名组匹配”，可以使用`\k<组名>`的写法

```js
const RE_TWICE = /^(?<word>[a-z]+)!\k<word>$/;
RE_TWICE.test('abc!abc') // true
RE_TWICE.test('abc!ab') // false
```

同时数字引用（`\1`）依然有效（代表第一个匹配项，`\2`为第二个匹配项）

```js
const RE_TWICE = /^(?<word>[a-z]+)!\1$/;
RE_TWICE.test('abc!abc') // true
RE_TWICE.test('abc!ab') // false
```

### 正则匹配索引

正则实例的`exec()`方法，返回结果有一个`index`属性，可以获取整个匹配结果的开始位置

为`exec()`方法的返回结果加上`indices`属性，在这个属性上面可以拿到匹配的开始位置和结束位置（目的解决包含组匹配而获取的开始位置）

备注： 浏览器中未看到 indices 属性

```javascript
const text = 'zabbcdef';
const re = /ab/;
const result = re.exec(text);

result.index // 1
result.indices // [ [1, 3] ]  //indices属性是一个数组，成员是每个匹配的开始位置和结束位置的数组

```

注意：开始位置包含在匹配结果之中，但是结束位置不包含在匹配结果之中。比如，匹配结果为`ab`，分别是原始字符串的第1位和第2位，那么结束位置就是第3位

如果正则表达式包含组匹配，那么`indices`属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置

```javascript
const text = 'zabbcdef';
const re = /ab+(cd)/;
const result = re.exec(text);

result.indices // [ [ 1, 6 ], [ 4, 6 ] ]

```

注意：这里的+是代表匹配多次b，因而结束位置是6

多组匹配例子：

```javascript
const text = 'zabbcdef';
const re = /ab+(cd(ef))/;
const result = re.exec(text);

result.indices // [ [1, 8], [4, 8], [6, 8] ]
```

总结：有n个组匹配，那么就有n+1个成员（一般而言）

如果正则表达式包含具名组匹配，`indices`属性数组还会有一个`groups`属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置

```javascript
const text = 'zabbcdef';
const re = /ab+(?<Z>cd)/;
const result = re.exec(text);

result.indices.groups // { Z: [ 4, 6 ] }
```

如果获取组匹配不成功，`indices`属性数组的对应成员则为`undefined`，`indices.groups`属性对象的对应成员也是`undefined`。

## Proxy和Reflect

`Proxy` 是对象的包装，将代理上的操作转发到对象，并可以选择捕获其中的一些操作。

它可以包装任何类型的对象，包括类和函数。

语法为：

```js
let proxy = new Proxy(target, {
  /* traps */
});
```

……然后，我们应该在所有地方使用 `proxy` 而不是 `target`。代理没有自己的属性或方法。如果提供了钩子，它将捕获操作，否则将其转发给 `target` 对象。

我们可以捕获：

- 读取（`get`），写入（`set`），删除（`deleteProperty`）属性（甚至是不存在的属性）。
- 函数调用（`apply` 钩子）。
- `new` 操作（`construct` 钩子）。
- 许多其他操作（完整列表在本文开头和 [docs](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FProxy) 中）。

这使我们能够创建“虚拟”属性和方法，实现默认值，可观察对象，函数装饰器等等。

我们还可以将对象多次包装在不同的代理中，并用多个函数进行装饰。

该[Reflect](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FReflect) API旨在补充 [Proxy](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FProxy)。对于任何 `Proxy` 钩子，都有一个带有相同参数的 `Reflect` 调用。我们应该使用它们将调用转发给目标对象。

Proxy 有一些局限：

- 内置对象具有“内部插槽”，对这些对象的访问无法被代理。请参阅上面的解决方法。
- 私有类字段也是如此，因为它们是在内部使用插槽实现的。因此，代理方法的调用必须具有目标对象 `this` 才能访问它们。
- 对象相等性测试 `===` 不能被拦截。
- 性能：基准测试取决于引擎，但通常使用最简单的代理访问属性所需的时间要长几倍。实际上，这仅对某些“瓶颈”对象重要。

### 参考

https://juejin.cn/post/6844904090116292616#heading-13

## Promise

```js
new Promise((resolve, reject)=>{resolve()})
  .then((res)=>{console.log(res)})
  .catch((err)=>{console.log(err)})
```

`Promise.all()`：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)

- 入参：具有`Iterator接口`的数据结构
- 成功：只有全部实例状态变成`fulfilled`，最终状态才会变成`fulfilled`
- 失败：其中一个实例状态变成`rejected`，最终状态就会变成`rejected`

`Promise.race()`：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)

- 入参：具有`Iterator接口`的数据结构
- 成功失败：哪个实例率先改变状态就返回哪个实例的状态

`Promise.resolve()`：将对象转为Promise对象 等价于`new Promise(resolve => resolve())`

`Promise.reject()`：将对象转为状态为`rejected`的Promise对象等价于`new Promise((resolve, reject) => reject())`

## Class

ES6 的 `class` 属于一种“语法糖”，所以只是写法更加优雅，更加像面对对象的编程，其思想和 ES5 是一致的。

类本身指向构造函数，所有方法定义在`prototype`上，可看作构造函数的另一种写法(`Class === Class.prototype.constructor`)

```js
function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function() {
  return '(' + this.x + ',' + this.y + ')';
}

// 等价于

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ',' + this.y + ')';
  }
}

class A {
    static classMethod() {
      this.baz(); // 如果静态方法包含this关键字，这个this指的是类，而不是实例。
    }
    static myStaticProp = 42;
    static baz() {
      console.log('hello');
    }
    baz() {
      console.log('world');
    }
}
A.classMethod();


```

super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。

子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。

注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。

```js
class A {
  constructor() {
    this.p = 2;
  }
}
// super --- A.prototype, 在普通方法中，指向父类的原型对象
// super --- A, 在静态方法中，指向父类
class B extends A {
  constructor() {
    super(); // A.prototype.constructor.call(this) 作为函数调用，代表父类的构造函数
  }
}
```

## Module

**export：规定模块对外接口**

默认导出：export default Person(导入时可指定模块任意名称，无需知晓内部真实名称)
单独导出：export const name = "Bruce"
按需导出：export { age, name, sex }
改名导出：export { name as newName }

**import：导入模块内部功能**

默认导入：import Person from "person"
整体导入：import * as Person from "person"
按需导入：import { age, name, sex } from "person"
改名导入：import { name as newName } from "person"
自执导入：import "person"
复合导入：import Person, { name } from "person"

**复合模式：export命令和import命令结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量**

默认导入导出：export { default } from "person"
整体导入导出：export * from "person"
按需导入导出：export { age, name, sex } from "person"
改名导入导出：export { name as newName } from "person"
具名改默认导入导出：export { name as default } from "person"
默认改具名导入导出：export { default as name } from "person"

## symbol

参考：https://juejin.cn/post/6857398814757224462

ES6 引入了一种**新的原始数据类型**`Symbol`，表示**独一无二**的值。可以从根本上防止**属性名**的冲突，`Symbol` 值通过**Symbol函数**生成

- `Symbol`是第七种数据类型，前六种为：`underfined`, `null`,`String`, `Boolean`, `Number`, `Object`
- `Symbol`函数前不能使用`new`命令，否则会报错。这是因为生成的 `Symbol` 是一个原始类型的值，不是对象。
- `Symbol`函数可以接受一个字符串作为参数，表示对 `Symbol` 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
- Symbol参数只是描述，相同参数返回的值是不相等的
- `Symbol` 值不能与其他类型的值进行运算，会报错。
- `Symbol` 的参数如果是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。
- `Symbol` 值可以显式转为字符串，也可以转为布尔值，但是不能转为数值。
- 读取描述一般要将symbol转化为字符串，ES2019提供了一个实例属性description，直接返回Symbol 的描述。
- 对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。
- `Symbol` 作为属性名，遍历对象的时候，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。有一个`Object.getOwnPropertySymbols()`方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
- 有时，我们希望重新使用同一个 `Symbol` 值，`Symbol.for()`方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 `Symbol` 值。如果有，就返回这个 `Symbol` 值，否则就新建一个以该字符串为名称的 `Symbol` 值，并将其注册到全局。
- Symbol.keyFor()方法返回一个*已登记* 的 Symbol 类型值的key。
- `Symbol()`写法**没有**登记机制 比如，如果你调用`Symbol.for("cat")`30 次，每次都会返回**同一个** `Symbol` 值,但是调用`Symbol("cat")`30 次，会返回 **30 个不同**的 `Symbol` 值。
- Symbol 本身有一些内置属性，用在底层对象上，例如：Symbol.hasInstance，instanceof 内置方法挂载方法的属性；Symbol.iterator， 迭代器对象挂载方法的属性

```js
let name = Symbol('lvxiaowei')
typeof name // 'symbol'
let obj = {}
obj[name] = 'lxw'
obj[name] // lxw
```

## Iterator

参考： https://juejin.cn/post/6844904000131694605

`Iterator` 是一种接口，目的是为不同的数据结构提供统一的数据访问机制，实现该接口的对象可以使用 for of 语法进行数据遍历，对于解构赋值，扩展运算符都会调用迭代器方法。

**既然他是一种接口，那我们应该怎样实现这个接口呢？实现规则是什么样的呢？**

因为 `javascript` 语言里没有接口的概念，这里我们可以理解成它是一种特殊的对象 - 迭代器对象，返回此对象的方法叫做迭代器方法。

首先他作为一个对象，此对象具有一个`next`方法，每次调用 `next` 方法都会返回一个结果值。

这个结果值是一个 `object`，包含两个属性，`value` 和 `done`。

`value`表示具体的返回值，`done` 是布尔类型的，表示集合是否遍历完成或者是否后续还有可用数据，没有可用数据则返回 `true`，否则返回 `false`。

另外内部会维护一个指针，用来指向当前集合的位置，每调用一次 `next` 方法，指针都会向后移动一个位置(可以想象成数组的索引)。

简单例子：

```js
const iterableObj = {
  items: ['a', 'b', 'c'],
  [Symbol.iterator]: function () {
    let i = 0;
    return {
      next: () => {
        var done = i >= this.items.length;
        var value = !done ? this.items[i++] : undefined;
        return {
          done: done,
          value: value
        };
      },
      return() {
        // 中断循环会调用
        console.log('提前退出');
        return {
          //必须返回一个对象
          done: true
        };
      }
    };
  }
};

for (let v of iterableObj) {
  if (v === 'a') {
    console.log('a continue');
    continue;
  }
  if (v === 'b') {
    console.log('b break');
    break;
  }
}

const [d,e]={name:'zhang'} // 会报错，不是一个可迭代对象
const [d,e]=iterableObj // 按顺序解构赋值，不会报错
```

已默认部署 Iterator 接口的对象主要包括数组、字符串、Set、Map 、类似数组的对象（比如arguments对象、DOM NodeList 对象）

既然可迭代对象的规则必须在对象上部署`Symbol.iterator`属性，那么我们基本上就可以通过此属来判断对象是否为可迭代对象，然后就可以知道是否能使用 `for of` 取值了。

## generator

参考：https://juejin.cn/post/6844903593976266760#heading-2

iterator写法比较麻烦，需要手动记录迭代的位置，和返回数据状态。generator可以方便的生成iterator。`generator` 就是一个返回值为 `iterator` 的函数。

```js
function* createIterator() {
  yield 1;
  yield 2;
  yield 3;
}
// generators可以像正常函数一样被调用，不同的是会返回一个 iterator
let iterator = createIterator();
console.log(iterator.next().value); // 1
console.log(iterator.next().value); // 2
console.log(iterator.next().value); // 3

// * 标明这是个 generators， yield 用来在调用 next时返回 value

[function] * [name]() {} // * 可以靠近关键字也可以靠近函数名，或两不靠近，都可以

// 注意： 需要注意的是，yield 不能跨函数；箭头函数不能用做 generator

// 可迭代对象的写法：
let collection = {
  items: [],
  *[Symbol.iterator]() {
    for (let item of this.items) {
      yield item;
    }
  }
};
```

## Set

参考： https://juejin.cn/post/6844903959283367950#heading-12

定义：类似于数组的数据结构，成员值都是唯一且没有重复的值
声明：const set = new Set(arr)
入参：具有Iterator接口的数据结构

### 属性

- constructor：构造函数，返回Set
- size：返回实例成员总数

### 方法

- add()：添加值，返回实例
- delete()：删除值，返回布尔
- has()：检查值，返回布尔
- clear()：清除所有成员
- keys()：返回以属性值为遍历器的对象
- values()：返回以属性值为遍历器的对象
- entries()：返回以属性值和属性值为遍历器的对象
- forEach()：使用回调函数遍历每个成员

### 重点难点

- 遍历顺序：插入顺序
- 没有键只有值，可认为键和值两值相等
- 添加多个`NaN`时，只会存在一个`NaN`
- 添加相同的对象时，会认为是不同的对象
- 添加值时不会发生类型转换(`5 !== "5"`)
- `keys()`和`values()`的行为完全一致，`entries()`返回的遍历器同时包括键和值且两值相等

## WeakSet

定义：和Set结构类似，成员值只能是对象

声明：`const set = new WeakSet(arr)`

入参：具有`Iterator接口`的数据结构

属性

- **constructor**：构造函数，返回WeakSet

方法

- **add()**：添加值，返回实例
- **delete()**：删除值，返回布尔
- **has()**：检查值，返回布尔

### 重点难点

- 成员都是`弱引用`，垃圾回收机制不考虑`WeakSet结构`对此成员的引用
- 成员不适合引用，它会随时消失，因此ES6规定`WeakSet结构不可遍历`
- 其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于`WeakSet结构`中

## Map

参考： https://juejin.cn/post/6844903959283367950#heading-15

定义：类似于对象的数据结构，成员键是任何类型的值
声明：const set = new Map(arr)
入参：具有Iterator接口且每个成员都是一个双元素数组的数据结构

### 属性

- constructor：构造函数，返回Map
- size：返回实例成员总数

### 方法

- get()：返回键值对
- set()：添加键值对，返回实例
- delete()：删除键值对，返回布尔
- has()：检查键值对，返回布尔
- clear()：清除所有成员
- keys()：返回以键为遍历器的对象
- values()：返回以值为遍历器的对象
- entries()：返回以键和值为遍历器的对象
- forEach()：使用回调函数遍历每个成员

### 重点难点

- 遍历顺序：插入顺序
- 对同一个键多次赋值，后面的值将覆盖前面的值
- 对同一个对象的引用，被视为一个键
- 对同样值的两个实例，被视为两个键
- 键跟内存地址绑定，只要内存地址不一样就视为两个键
- 添加多个以`NaN`作为键时，只会存在一个以`NaN`作为键的值
- `Object结构`提供`字符串—值`的对应，`Map结构`提供`值—值`的对应

## WeakMap

定义：和Map结构类似，成员键只能是对象

声明：`const set = new WeakMap(arr)`

入参：具有`Iterator接口`且每个成员都是一个双元素数组的数据结构

属性

- **constructor**：构造函数，返回WeakMap

方法

- **get()**：返回键值对
- **set()**：添加键值对，返回实例
- **delete()**：删除键值对，返回布尔
- **has()**：检查键值对，返回布尔

### 重点难点

成员键都是`弱引用`，垃圾回收机制不考虑`WeakMap结构`对此成员键的引用

成员键不适合引用，它会随时消失，因此ES6规定`WeakMap结构不可遍历`

其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于`WeakMap结构`中

一旦不再需要，成员会自动消失，不用手动删除引用

弱引用的`只是键而不是值`，值依然是正常引用

即使在外部消除了成员键的引用，内部的成员值依然存在

